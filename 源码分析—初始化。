关于迅雷协议
（）
snort.c：
        a）初始化：完成检测数据包之前的所有工作
        b）数据包处理：完成数据包从嗅探到报日志输出等工作
SnortMain()：整个系统的主体
a）初始化：
        前期准备工作
        打开数据包截获接口
        插件初始化
        规则链表初始化
        规则快速匹配引擎初始化
b）数据包处理
        数据包截获
        数据包解码
        处理嗅探模式和日志记录模式
        数据包预处理
        数据包检测
        日志及报警的输出
全局变量Packet数据结构（decode.h）：控制着整个系统正常工作的关键信息。里面包含Snort支持的相关协议的对应结构
        指示原始数据包截获信息的字段，包含*pkth 和*pkt指针字段
        用于存放当前数据包进行协议解析后所得信息的字段，都对应了相应的协议，只要了解对应的协议的包的结构，了解就很容易
        标识字段
全局变量pv：存储了系统运行时需要的绝大部分标志信息。
                存储了系统配置信息和命令行参数解析后的结果信息，从而对系统的众多控制标识符的设置起着很重要的作用
        定义在snort.h中
系统初始化：
检测引擎初始化：fpInitDetectionEngine()配置检测引擎的一些默认参数，即初始化FPDETECT（fpcreate.h）
        对fpDetect赋初值
        调用fpSetDetectionOption函数，将值传递给定义于fpDetect.c中的fpDetect
命令行初始化：

命令行解析
ParseCmdLine函数中while/switch/case，其利用getopt()循环分析读取命令行参数，交于ch进行匹配。
打开数据截获接口：
libpcap库函数：
	pcap_lookupdev( )：查找第一个可以使用的网络适配器
	pcap_open_live( )：获取适配器的描述信息
	pcap_open_live( )：打开网卡
	pcap_open_offline( )：从文件读取数据包
	pcap_snapshot( )：获取数据链路层的类型
	pcap_compile( )，pcap_setfilter( )：设置过滤规则
	pcap_loop( )：捕获数据包
OpenPcap()函数调用以上所有函数，完成包截获引擎在截获之前的所有工作。
	1.Snort数据包的获得有两种来源：从网络或文件中获取。
	2.snaplen = pcap_snapshot(pd);后面，主函数会调用SetPktProcessor函数来根据snaplen的值判断该调用何种对应的拆包函数。
插件初始化：日志输出插件，预处理插件，检测插件。链表来处理
注册——初始化——调用
输出插件注册初始化：（snort运行到InitOutputPlugins()函数时仅仅是注册，当后面进行规则解析时才能“顺便”初始化）
注册：OutputKeyWordList插件链表的节点，封装了关键字节点。OutputKeywordNode
注册函数setup又通过调用RegisterOutputPlugin来注册实现，RegisterOutputPlugin负责了链表的搭建，其算法思想是判断链表是否位空
		，为空则新建链表和头节点，否则在链表尾添加一个新节点，
初始化函数：
	读取相关插件的配置参数
	将插件名和实际处理函数建立到一个链表中，以供系统后面调用。输出插件有两个链表LOG和ALERT
规则字符串查找分析：主函数通过调用规则拆分函数ParseRule来读取snort.conf相关配置语句，实现输出插件初始化相关工作。
规则配置及字符串拆分：ParseOutputPlugin函数是完成输出插件初始化的主要函数。mSplit函数：用于字符串的拆分，
			GetOutputPlugin函数用于从输出插件注册链表中获取与当前插件名对应的节点。
初始化函数：Syslog插件
预处理插件初始化：数据包在进入检测引擎之前，对其进行前期的一些处理。（过程和输出插件差不多）
	分片的数据包需要重组
	HTTP请求的URL字符串需要统一格式化
	需要识别扫描探测等行为
PreprocessKeywordlist：封装了关键字节点PreprocessNode
注册：主函数调用InitPreprocessors （plugbase.c）函数进行预处理插件的初始化。
	函数每次调用setup××函数来实现每一个对应的预处理插件的初始化。注册的基本思想是将关键字名相应的处理函数进行绑定
	再构建链表。每一个setup××函数都是通过调用了RegisterPreprocessor函数来实现注册的，其两个参数分别表示插件名和
	对应的处理函数。
初始化：1.主函数用ParseRuleFile，从snort.conf配置文件中一行一行的读取配置参数，交于ParseRule函数进一步拆分
	2.ParseRule函数分析每一行的配置，判断配置的类型，若是预处理插件的配置，则调用ParsePreprocessor
	进一步分析预处理插件的配置
	3.ParsePreprocessor（parser.c）函数将取出配置文件中使用的预处理插件的插件名字关键字，然后遍历注册时建立的链表
各种预处理插件的过程都很相似：
	1.拆解分析配置函数,填充相应的数据结构
	2.将该预处理器插件的实际功能函数，填充至实际执行的预处理插件链表
	3.将退出清理函数填充至实际执行的预处理插件链表
	4.将其重置函数填充至实际执行的预处理插件链表
流跟踪模块主要用于建立和维护一个连接状态表（协议、来源地址、目的地址、来源端口、目的端口）对应的数据结构SPPFLOW_CONFIG（spp_flow.c）
所有的量表建立好以后，待诱截获到数据包后对数据包进行逐一的调用，对数据包进行预处理。
调用：函数Preprocess
规则选项关键字插件初始化（检测插件）：
InitPlugIns函数注册（与前面相似）setup××——RegisterPlugin
五，检测规则初始化引擎
三维链表来组织规则。
	首层链表定义了五个RuleListNode结构的节点RuleListNode：alter,log,pass,active,dynamic。每个动作的规则再按协议来划分，
而且如果数据包于规则相匹配需要输出的话还要调用对应的输出插件。即位第二层数据结构，ListHead。规则头除了包含动作、协议外，
还有在此协议下的地址、端口、数据流方向等，于是加上一些控制标志，即为第三层链表节点RuleTreeNode（RTN）。RTN用Right来指向下一个节点，
down指向第四层的数据节点：规则节点选项OptTreeNode（OTN）。
规则初始化流程：CreateDefaultRules函数完成第一层链表的搭建。ParseRuleFile读取snort.conf等配置文件，将配置文件一行一行送往
ParseRule解析，交回文件名，两个函数反复回调，完成规则的初始化过程。
CreateDefaultRules搭建最上层链表通过五次调用CreateRuleType函数实现。CreateRuleType函数负责链表的具体实现。
ParseRule函数打开参数char *file指向的文件，然后一行一行的读取文件，再交由后续函数处理。
ParseRule :
	函数负责将上层函数ParseRuleFile传递过来的一行字符串进行进一步分解，提出指令类型，再进一步判断，调用相应的处理函数。
获取规则类型RuleType——属于检测规则类型？——处理规则头ProcessHeadNode——ProcessRuleOption
				——调用对应的解析模块——ParsePreprocesstor,ParseOutPutPlugins,ParseConfig,ParseRuleTypeDeclaration
函数ParseRule在进行规则头的IP地址处理的时候，调用了ProcessIP函数来向RTN填充源/目的ip地址及掩码的信息。ProcessIP函数
将规则头中IP地址信息的集中相关字符串分别一一进行处理。
函数ParsePort用于拆分规则头中的端口子串，将分析后的结果填充RTN结构的相应成员变量。



